\documentclass{book}
\usepackage{listings}

\begin{document}
\chapter{Introduction}



\section{Motivation for CLCB}

Lisp is fun. And it was felt that for a particular problem at hand, 
there was little gained by using Bio* libraries for Java, Python or Perl.
Hence, the decision was made to implement in Lisp and from day one kept in
mind to offer the fun to others, too.

One can program Lisp as if it was Perl, which is referred to as
''declarative''. What Lisp once was special for is the {\em fun}ctional
programming. Everyone has experienced what functional programming is alike
who has specified the first argument to the {\em sort} routine in Perl,
which is the expression deciding if the objects \$a or \$b is larger, with
a non-trivial expression.  In Lisp,
such functions that do not need a name are called $\lambda$ expressions.
One takes such, optionally gives them a name to make them real functions,
and applies them to lists (or another structure) of objects. To the biologically minded in us,
such functions are much like an enzyme that is acting on some sequence of
nucleotides. In other languages one only ''calls'' functions by name. In Lisp, functions are something tangible. Admittedly, these other languages do offer constructs that allow for a functional
programming to some degree. But with Lisp it is the other way around.

But exactly {\em why} is it so much fun? There are probably many answers
to this questions.  For one, the language is very clean, even for concepts
that came into fashion twenty years after Lisp's conception. Take
for instance the overloading of methods when introducing a subclass.
When interating over a set of zoo animals, there is no need for the
typical switch statement to learn about the object's real type and then a
cast to call the real method. If in C or Java you would do something alike

\lstset{language=C}
\begin{lstlisting}
	for(animal *a= alist->first(); a->next();) {
		if ("dog"==typeof(a)) {
			dog *d = (dog *)a;
			d->speak();
		}
		else if ("cat"==typeof(a)) {
		...
		}
	}
\end{lstlisting}

to hear the miows and barks.  In Lisp, you'd get the sound directly for
any animal, also for the ones not originally anticipated in that zoo loop.
For bioinformatics, with its zoo of sequence types and their subtypes,
the genes and what was formerly known as "junk", such cleanliness is essential.

There are other reasons $\ldots$

\section{How to learn Lisp}

The Net is full of tutorials that introduce to the language
Lisp. We found the instructions at the GMU very good to follow
(http://www.cs.gmu.edu/~sean/lisp/LispTutorial.html). A much recommended
text book is

	Peter Seibel\\
	Practical Common Lisp\\
	ISBN 1-59059-239-5\\
	Apress

A more biologically inclined reader of this document may decide
to leave the syntax of the language aside while first passing through
this document and instead concentrate more on the understanding
of the classes that represent biological entities in CLCB.

\section{Instant access to CLCB without reading this documentation}

CLCB is developed with SBCL but should be compatible with other
implementations with Lisp. This section gives you a head start into the
code. Frankly, the real documentation is in the code, literally, this is
where '':documentation'' slots allow for the annotation of what was
programmed and we prepare to parse that information from the code into
this document. But this is only now being worked on.
Unless you have a colleague who is already proficient in CLCB, 
there is no alternative to jumping right in.

\subsection{Setting up the interpreter}

In your UNIX shell change the directory to where the README 
of CLCB is. The UNIX command ''pwd'' informs about the current
working directory. Then start the Lisp interpreter, possibly just
by typing ''sbcl''. The interpreted now needs to learn about 
where to find your CLCB source code. To achieve that, in the lines below
substitute ''path/to/CLCB'' with that the command ''pwd'' just sent to
the screen and type it into the interpreter. You'd need to do this
every time you start up. Your interpreter will have files it reads at
startup and you should in the longer run move these lines there.

\lstset{language=lisp}
\begin{lstlisting}
(pushnew <path/to/CLCB> asdf:*central-registry*)
(pushnew <path/to/CLCB/ensembl> asdf:*central-registry*)
(asdf:oos 'asdf:load-op :clcb) or
(asdf:oos 'asdf:load-op :clcb-ensembl)
(in-package :ensembl)
\end{lstlisting}

\subsection{First hands on experience}

When looking at the examples given below you need to keep in mind that
computer scientists try hard to distinguish between the data and the
way it is presented to the user. The reason is that the same data
is interpreted differently in different contexts and there is hence
no way to know for sure how the data shall be shown to meet the user's
expectations. The examples below give references to the data, indicating
that all data is available to the programmer. This is great to the
programmer, saving lots of work. An abstract way to present the data,
i.e, as LaTeX tables, ASCII with white space or tab delimited, is still
being designed.

The code below retrieves a gene from Ensembl, retrieves its transcripts and finally the first transcript's protein protein product. Be aware that the translation process uses ''*'' to refer to the result of the previous command.

\begin{lstlisting}
ENSEMBL> (fetch-by-stable-id ``ENSG00000000005'')
=> #<GENE {C974EC1}>

(defparameter *gene* (fetch-by-stable-id ``ENSG00000000005''))

ENSEMBL> (transcripts *gene*)
=> (#<TRANSCRIPT {CAB4751}>)

ENSEMBL> (translation (car *))
=> #<TRANSLATION {CAF4C49}>
\end{lstlisting}

Retrieval of exons that contribute to the first transcript.
\begin{lstlisting}
ENSEMBL> (exons (first (transcripts *gene*)))
=> 
(#<EXON {CB4F9E9}> #<EXON {CB5C809}> #<EXON {CB69539}> #<EXON {CB76249}>
 #<EXON {CB831E9}> #<EXON {CB8FF09}> #<EXON {CB9CC09}> #<EXON {CBA98E9}>
 #<EXON {CBB6619}> #<EXON {CBC3329}> #<EXON {CBD0011}> #<EXON {CBDCD09}>
 #<EXON {CBE9A09}> #<EXON {CBF6729}> #<EXON {CC03421}> #<EXON {CC10149}>
 #<EXON {CC1CE61}> #<EXON {CC2BB61}> #<EXON {CC3A8A9}> #<EXON {CC47AD1}>
 #<EXON {CC56809}>)
\end{lstlisting}

Retrieval of features of the first transcript's protein product.

\begin{lstlisting}
ENSEMBL> (protein-features (translation (car (transcripts *gene*))))
(#<PROTEIN-FEATURE {CD15729}> #<PROTEIN-FEATURE {CD178C9}>
 #<PROTEIN-FEATURE {CD18591}> #<PROTEIN-FEATURE {CD19269}>
 #<PROTEIN-FEATURE {CD19F31}> #<PROTEIN-FEATURE {CD1ABF9}>
 #<PROTEIN-FEATURE {CD1B8C9}> #<PROTEIN-FEATURE {CD1C591}>)
ENSEMBL> (mapcar #'protein-feature-type
                 (protein-features (translation (car (transcripts *gene*)))))
("Pfam" "Superfamily" "Superfamily" "Smart" "low_complexity" "low_complexity"
 "low_complexity" "Prosite_profiles")
\end{lstlisting}

Genomic coordinates of the protein features. But where is the chromosome
and where the organism? Well, normally you know about these already and they
are invariant whenever one is inspecting a particular protein that is not
a product of a translocation $\ldots$ hm $\ldots$ . It is the gene that can
be queries for the chromosome.

\begin{lstlisting}
(mapcar #'dna-sequence-interval
                 (protein-features (translation (car (transcripts *gene*)))))
(#<DNA-SEQUENCE {D1DF909}>
 #<MULTI-INTERVAL (#<DNA-SEQUENCE {D1FD389}> #<DNA-SEQUENCE {D1FE011}>)>
 #<MULTI-INTERVAL (#<DNA-SEQUENCE {D21BEF1}> #<DNA-SEQUENCE {D21CB71}> #<DNA-SEQUENCE {D21D7F1}>)>
 #<DNA-SEQUENCE {D2D2A01}> #<DNA-SEQUENCE {D2EA241}> #<DNA-SEQUENCE {D3019E1}>
 #<MULTI-INTERVAL (#<DNA-SEQUENCE {D320179}> #<DNA-SEQUENCE {D320DF9}>)>
 #<DNA-SEQUENCE {D342429}>)
ENSEMBL> (mapcar #'(lambda (x) (genomic-coordinates (dna-sequence-interval x)))
                 (protein-features (translation (car (transcripts *gene*)))))
((204639 . 204885) (204630 . 205434) (250229 . 255355) (204639 . 204918)
 (242551 . 242602) (216822 . 216855) (204921 . 205473) (204639 . 204888))
ENSEMBL> (chromosome *gene*)
"18"

\end{lstlisting}


\end{document}
